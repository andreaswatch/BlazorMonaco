@page "/"

<h3>Code Editor</h3>

<div>
    <div style="margin:10px 0;">
        Theme:
        <select @onchange="ChangeTheme">
            <option value="vs">Visual Studio</option>
            <option value="vs-dark">Visual Studio Dark</option>
            <option value="hc-black">High Contrast Black</option>
        </select>
    </div>
    <div style="margin:10px 0;">
        New Value: <input type="text" @bind="ValueToSet" style="width: 400px;" /> <button @onclick="SetValue">Set Value</button>
    </div>
    <div style="margin:10px 0;">
        <button @onclick="GetValue">Get Value</button>
    </div>
    <div style="margin:10px 0;">
        <button @onclick="AddCommand">Add Command (Ctrl+Enter)</button>
    </div>
    <div style="margin:10px 0;">
        <button @onclick="AddAction">Add Action (Ctrl+D)</button>
    </div>
    <div style="margin:10px 0;">
        See the console for results.
    </div>
</div>

<MonacoEditor @ref="_editor" Id="sample-code-editor-123" ConstructionOptions="EditorConstructionOptions" OnDidInit="EditorOnDidInit" OnContextMenu="OnContextMenu" />

@code {
    private MonacoEditor _editor { get; set; }
    private string ValueToSet { get; set; }

    private StandaloneEditorConstructionOptions EditorConstructionOptions(MonacoEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            Language = "javascript",
            GlyphMargin = true,
            Value = "\"use strict\";\n" +
                    "function Person(age) {\n" +
                    "	if (age) {\n" +
                    "		this.age = age;\n" +
                    "	}\n" +
                    "}\n" +
                    "Person.prototype.getAge = function () {\n" +
                    "	return this.age;\n" +
                    "};\n"
        };
    }

    private async Task EditorOnDidInit(MonacoEditorBase editor)
    {
        await _editor.AddCommand((int)KeyMode.CtrlCmd | (int)KeyCode.KeyH, (editor, keyCode) =>
        {
            Console.WriteLine("Ctrl+H : Initial editor command is triggered.");
        });

        var newDecorations = new ModelDeltaDecoration[]
        {
            new ModelDeltaDecoration
            {
                Range = new BlazorMonaco.Range(3,1,3,1),
                Options = new ModelDecorationOptions
                {
                    IsWholeLine = true,
                    ClassName = "decorationContentClass",
                    GlyphMarginClassName = "decorationGlyphMarginClass"
                }
            }
        };

        decorationIds = await _editor.DeltaDecorations(null, newDecorations);
        // You can now use 'decorationIds' to change or remove the decorations
        
        #region Usage example or MonarchTokens
        await MonacoEditorBase.CreateLanguage(new MonarchLanguage
        {
            Id = "customCsharp"
        });

        await MonacoEditorBase.SetMonarchTokensProvider("customCsharp", new MonarchLanguageRules
        {
            Keywords = new List<string>
            {
                "abstract", "continue", "for", "new", "switch", "assert", "goto", "do",
                "if", "private", "this", "break", "protected", "throw", "else", "public",
                "enum", "return", "catch", "try", "interface", "static", "class",
                "finally", "const", "while", "true", "false", "using", "namespace", "override",
                "async", "base", "await", "default", "where", "in", "from", "select", "and", "or",
            },
            TypeKeywords = new List<string>
            {
                "bool", "double", "uint", "int", "float", "short", "ushort", "char", "long",
                "ulong", "void", "var"
            },
            Operators = new List<string>
            {
                "=", ">", "<", "!", "~", "?", ":", "==", "<=", ">=", "!=",
                "&&", "||", "++", "--", "+", "-", "*", "/", "&", "|", "^", "%",
                "<<", ">>", ">>>", "+=", "-=", "*=", "/=", "&=", "|=", "^=",
                "%=", "<<=", ">>=", ">>>="
            },
            Tokenizer = new TokenizerData
            {
                Root = new List<MonarchRoot>
                {
                    /* Notes:
                    Order is important, top have priority for highlighting.
                    If you have two regex with approximately the same pattern,
                    one of this can be not highlighted */ 
                    new()
                    {
                        Pattern = @"my-custom-keyword",
                        Token = new MonarchTokenValue("myKeyword")
                    },
                    new()
                    {
                        Pattern = @"// *(\S+)? *",
                        Token = new MonarchTokenValue("comment")
                    },
                    new()
                    {
                        Pattern = @"\/\* *(?:\n+)?(\S+)? *(?:\n+)?\*\/",
                        Token = new MonarchTokenValue("comment")
                    },
                    new()
                    {
                        Pattern = @"@\s*[a-zA-Z_\$][\w\$]*",
                        Token = new MonarchTokenValue(new ConditionToken
                        {
                            Token = "annotation",
                            Log = "annotation token: $0"
                        })
                    },
                    new()
                    {
                        Pattern = @"[a-z_$][\w$]*",
                        Token = new MonarchTokenValue(new CaseToken
                        {
                            Cases = new List<MonarchCase>
                            {
                                // Import from a list created in MonarchLanguageRules class.
                                
                                /* By example, if you add: new("keyword", nameof(MonarchLanguageRules.MyCustomListOfKeyword))
                                 ou need to create a list of string with name MyCustomListOfKeyword in MonarchLanguageRules class,
                                // without this an error is occurred*/
                                
                                new("keyword", nameof(MonarchLanguageRules.TypeKeywords)),
                                new("keyword", nameof(MonarchLanguageRules.Keywords)),
                            }
                        })
                    },
                    new()
                    {
                        Pattern = @"[=><!~?:&|+\-*\/\^%]+",
                        Token = new MonarchTokenValue(new CaseToken
                        {
                            Cases = new List<MonarchCase>
                            {
                                new("operator", nameof(MonarchLanguageRules.Operators)),
                            }
                        })
                    },
                    new()
                    {
                        Pattern = @"[{}()\[\]]",
                        Token = new MonarchTokenValue("brackets")
                    }
                }
            }
        });

        await MonacoEditorBase.DefineTheme("my-custom-theme", new StandaloneThemeData
        {
            Base = "vs-dark",
            Inherit = true,
            Rules = new List<TokenThemeRule>
            {
                new TokenThemeRule { Background = "363636", Foreground = "E0E0E0" },
                new TokenThemeRule { Token = "operator.sql", Foreground = "59ADFF" },
                new TokenThemeRule { Token = "number", Foreground = "cc6672" },
                new TokenThemeRule { Token = "string.sql", Foreground = "E65C5C" },
                new TokenThemeRule { Token = "variable", Foreground = "4287f5" },

                // Dot not miss to add tokens created in SetMonarchTokensProviderToken
                new TokenThemeRule { Token = "keyword", Foreground = "6b6bff" },
                new TokenThemeRule { Token = "brackets", Foreground = "6b6bff" },
                new TokenThemeRule { Token = "operator", Foreground = "ff7a6b" },
                new TokenThemeRule { Token = "comment", Foreground = "7A7A7A" },
                new TokenThemeRule { Token = "myKeyword", Foreground = "42f593" },
            },
            Colors = new Dictionary<string, string>
            {
                ["editor.background"] = "#121218",
                ["editorCursor.foreground"] = "#E0E0E0",
                ["editorLineNumber.foreground"] = "#7A7A7A"
            }
        });

        await MonacoEditorBase.SetTheme("my-custom-theme");
        #endregion
    }

    private string[] decorationIds;

    private void OnContextMenu(EditorMouseEvent eventArg)
    {
        Console.WriteLine("OnContextMenu : " + System.Text.Json.JsonSerializer.Serialize(eventArg));
    }

    private async Task ChangeTheme(ChangeEventArgs e)
    {
        Console.WriteLine($"setting theme to: {e.Value.ToString()}");
        await MonacoEditor.SetTheme(e.Value.ToString());
    }

    private async Task SetValue()
    {
        Console.WriteLine($"setting value to: {ValueToSet}");
        await _editor.SetValue(ValueToSet);
    }

    private async Task GetValue()
    {
        var val = await _editor.GetValue();
        Console.WriteLine($"value is: {val}");
    }

    private async Task AddCommand()
    {
        await _editor.AddCommand((int)KeyMode.CtrlCmd | (int)KeyCode.Enter, (editor, keyCode) =>
        {
            Console.WriteLine("Ctrl+Enter : Editor command is triggered.");
        });
    }

    private async Task AddAction()
    {
        await _editor.AddAction("testAction", "Test Action", new int[] { (int)KeyMode.CtrlCmd | (int)KeyCode.KeyD, (int)KeyMode.CtrlCmd | (int)KeyCode.KeyB }, null, null, "navigation", 1.5, (editor, keyCodes) =>
        {
            Console.WriteLine("Ctrl+D : Editor action is triggered.");
        });
    }
}
